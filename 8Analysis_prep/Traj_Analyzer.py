import pandas as pd
from matplotlib import pyplot as plt
import seaborn as sns
import numpy as np

sns.set(font_scale=2) 
sns.set_style("ticks")


def score(basepath, subpath, csv_name, by_frame = True):
    '''
    Calculate the stability score of each simulation trajectory and save each score into a .csv file

    Parameters
    ----------
    basepath : str
        The basepath of source file
    
    subpath : str
        The subpath of source file (contact_frame.dat)
    
    csv_name : str
        The path to the output file, the total score (.csv)
    
    by_frame : boolean
        If False, save average score; If True, save score of each frame
    
    '''

    score_list = []                                # The list of the stability score of each trajectory
    score_by_frame = pd.DataFrame({'contact[native]':[]})               # The list of the stability score by frame of each trajectory
    for i in range(1,4):
        score_df = pd.read_csv(basepath+subpath%(i), delim_whitespace=True, skiprows=0)
        score = score_df['contact[native]'].div(score_df['contact[native]'][0]).iloc[100:201]          # Calculate the score
        
        score_list.append(score.mean())
        print('Simulation %s score: '%(i),score.mean())

        score_by_frame = score_by_frame.append(pd.DataFrame({'Score':score.values}), ignore_index = True)

    print()
    print("Total average score is ",np.mean(score_list))
    
    if by_frame:
        score_by_frame.to_csv(csv_name, index=False)         # Save score by frame to csv_name
    
    else:
        score_df = pd.DataFrame({'Score':score_list})  # Dataframe for native contact score for all 3 trajectories
        score_df.to_csv(csv_name, index=False)         # Save each score to csv_name



def scorePlot(basepath, subpath, title_name, fig_name):
    ''''''
    plt.figure(figsize=(30, 8))    
    for i in range(1,4):
        plt.subplot(1,3,i)                                                           # The ith subplot          
        score_df = pd.read_csv(basepath+subpath%(i), delim_whitespace=True, skiprows=0)
        score = score_df['contact[native]'].div(score_df['contact[native]'][0])
        
        # PLOT 
        plt.plot(score.index, score.values)
        
        # TITLE ETC. 
        plt.title(title_name+'%s'%i)
        plt.ylabel('Stability Score by Frame')
        plt.xlabel('time/ns')
        
    plt.savefig(fig_name,bbox_inches='tight',transparent=True)                       # Save figure to fig_name



def rmsdPlot(basepath, rec_subpath, lig_subpath, title_name, fig_name, rec_name, lig_name):
    '''
    Plot the rmsd changes of the receptor and ligand of each trajectory, and save the plot as a .png file
    
    Parameters
    ----------
    basepath : str
        The basepath of source file
    
    rec_subpath : str
        The subpath of source file (.rms files) of the receptor
    
    lig_subpath : str
        The subpath of source file (.rms files) of the ligand
    
    title_name : str
        The title of the figure

    fig_name : str
        The path to the output file (.png)
    
    rec_name : str
        The name of the receptor

    lig_name : str
        The name of the ligand
    
    '''
    plt.figure(figsize=(30, 8))    
    for i in range(1,4):
        plt.subplot(1,3,i)                                                           # The ith subplot          
        receptor = pd.read_csv(basepath+rec_subpath%(i,i), delim_whitespace=True)
        ligand = pd.read_csv(basepath+lig_subpath%(i,i), delim_whitespace=True)
        RMSD_receptor = receptor['RMSD_00002']                                       # Dataframe of receptor data
        RMSD_ligand = ligand['RMSD_00002']                                           # Dataframe of ligand data
        
        # PLOT 
        plt.plot(range(len(RMSD_receptor)),RMSD_receptor,label=rec_name)
        plt.plot(range(len(RMSD_ligand)),RMSD_ligand,label=lig_name)
        
        # LEGEND & TITLE & ETC. 
        plt.legend()
        plt.title(title_name+'%s'%i)
        plt.ylabel('RMSD')
        plt.xlabel('time/ns')
        
    plt.savefig(fig_name,bbox_inches='tight',transparent=True)                       # Save figure to fig_name


def energySample(basepath, subpath, csv_name, sim_list, col_list, text, subtract=False, sampling=False, n_size=1):
    '''
    Sample the data points of MMPBSA, and save sampled points to a .csv file
    
    Parameters
    ----------
    basepath : str
        The basepath of source file
    
    subpath : str
        The subpath of source file (.csv file generated by MMPBSA run)
    
    csv_name : str
        The path to the output file (.csv)
    
    sim_list : int[]
        The list of trajectory indices t be analyzed (based on score)

    col_list : str[]
        The list of columes to be analyzed ('DELTA TOTAL', 'VDWAALS', 'EEL', 'ENPOLAR', 'EPB')
    
    text : str
        The text to be printed ("Total Energy", "Packing/Hydrophobic Effect", etc)
    
    subtract : boolean
        If False, just save target data indicated by col; If True, subtract col from Delta Total
    
    sampling : boolean
        If False, do not do sampling; If True, sample from datasets with size indicated by n_size
        
    n_size : int
        Sample size in each trajectory
    
    '''
    sim_all = pd.DataFrame()                  # Dataframe for raw energy data
    
    for i in sim_list:
        sim = pd.read_csv(basepath+subpath%(i,i), skiprows=464)

        cavg = pd.DataFrame()                 # Dataframe of cumulative average of all data points from col
        sim_equil = pd.DataFrame()            # Dataframe for equilibrated data points from col
        for col in col_list:
            cavg_col = sim[col].expanding().mean().to_frame(name = text)
            sim_equil_col = sim[col].iloc[51:151].to_frame(name = text)
            cavg = cavg.add(cavg_col, fill_value = 0.0)
            sim_equil = sim_equil.add(sim_equil_col, fill_value = 0.0)

        if subtract == False:
            print('The cumulative average '+text+' of sim %s'%(i),cavg.iloc[150])
            if sampling == False:
                sim_sample = sim_equil
            else:
                sim_sample = sim_equil.sample(n=n_size, replace = False) # Random sample from equilibrated data points (Order rearranged)        
        else:
            print('%s subtracted from Total Energy'%(text))
            sim_subtract = sim['DELTA TOTAL'].iloc[51:151].to_frame(name = text).subtract(sim_equil) # Dataframe for subtracted data points
            if sampling == False:
                sim_sample = sim_subtract
            else:
                sim_sample = sim_subtract.sample(n=n_size, replace = False) # Random sample from subtracted data points (Order rearranged)

        sim_all=sim_all.append(sim_sample, ignore_index=True)

    if subtract == False:
        sim_all.to_csv(csv_name, index=False)
    else:
        sim_all.to_csv(csv_name, index=False, header=['sub-%s'%(text)]) # Save sampled data points to csv_name


def energyPlot(basepath, subpath, col_list, title_name, y_label, fig_name):
    '''
    Plot the energy change of each trajectory, including individual data points and cumulative 
    average data points, and save the plot as a .png file
    
    Parameters
    ----------
    basepath : str
        The basepath of source file
    
    subpath : str
        The subpath of source file (.csv file generated by MMPBSA run)
    
    col_list : str[]
        The list of columes to be analyzed ('DELTA TOTAL', 'VDWAALS', 'EEL', 'ENPOLAR', 'EPB')
    
    title_name : str
        The title of the figure

    y_label : str
        The label of y axes

    fig_name : str
        The path to the output file (.png)
    
    '''
    plt.figure(figsize=(24, 8),dpi=150)
    color_list = ['dum','r','g','b']
    for i in range(1, 4):
        sim = pd.read_csv(basepath+subpath%(i,i),skiprows=464)
        
        cavg = pd.DataFrame()              # Dataframe of cumulative average data points
        sim_total = pd.DataFrame()         # Dataframe of individual data points
        for col in col_list:
            sim_col = sim[col].to_frame(name = 'a')                          
            cavg_col = sim[col].expanding().mean().to_frame(name = 'a')
            sim_total = sim_total.add(sim_col, fill_value = 0.0)
            cavg = cavg.add(cavg_col, fill_value = 0.0)
        
        # PLOT 
        plt.plot(np.array(range(len(cavg)))+50,cavg,label='Sim %s'%i,color=color_list[i],linewidth=2)
        plt.plot(np.array(range(len(sim_total)))+50,sim_total,'.',label='Sim %s'%i,color=color_list[i])
        
        # LEGEND & TITLE & ETC. 
        plt.legend()
        plt.title(title_name)
        plt.ylabel(y_label)
        plt.xlabel('Time (ns)')
    
    plt.savefig(fig_name,bbox_inches='tight',transparent=True)